use std::str::FromStr;
use crate::ast::nodes::*;
use crate::ast::Span;

grammar;

pub Program: Box<Program> = {
	(Stmt)+ => Box::new(Program::new(<>)),
};

Stmt: Box<Stmt> = {
	#[precedence(level="0")]
	<t:VarDecl> ";" => t,
	#[precedence(level="1")]
	<t:Expr> ";" => Box::new(Stmt::Expr(t)),
	While,
	Block,
	For,
	If,
	Return,
	Continue,
	Break,
	StructDecl,
	FunctionDecl,
	TraitDecl,
	VarAssign,
	DerefAssign,
	StructAssign,
	StructMemberAssign,
	ArrayAssign,
	ArrayMemberAssign,
};

Atom: Box<Expr> = {
	Numeric,
	Strng,
	Flt,
	Chr,
	Bln,
	<l:@L> <val:Iden> <r:@R> => Box::new(Expr::Iden{
		val: val,
		span: Span::new(l as u32, r as u32),
	}),
	Index,
	Call,
	MemberAccess,
};

Bracketed : Box<Expr> = {
	"(" <t:Expr> ")" => t,
};

Expr: Box<Expr> = {
	#[precedence(level="0")]
	Bracketed => <>,
	Atom => <>,
	#[precedence(level="1")] #[assoc(side="left")]
	UnaryOp,
	#[precedence(level="2")] #[assoc(side="left")]
	BinaryOp,
};

Numeric: Box<Expr> = {
	<l:@L> <val:r"[0-9]+"> <r:@R> => Box::new(Expr::Numeric {
		val: FromStr::from_str(val).unwrap(),
		span: Span::new(l as u32, r as u32),
	}),
};

Strng: Box<Expr> = {
	<l:@L> <val:r#""[^"]*""#> <r:@R> => {
		let s = val.to_string();
		let s = s[1..s.len()-1].to_string();
		Box::new(Expr::Strng {
			val: s,
			span: Span::new(l as u32, r as u32),
		})
	},
};

Flt: Box<Expr> = {
	<l:@L> <val:r"[0-9]+\.[0-9]+"> <r:@R> => {
		let val = FromStr::from_str(val).unwrap();
		Box::new(Expr::Flt {
			val: val,
			span: Span::new(l as u32, r as u32),
		})
	},
};

Chr: Box<Expr> = {
	<l:@L> <val:r"'.'"> <r:@R> => Box::new(Expr::Chr {
		val: val.chars().nth(1).unwrap(),
		span: Span::new(l as u32, r as u32),
	}),
};

Bln: Box<Expr> = {
	"true" => Box::new(Expr::Bln{
		val: true,
		span: Span::new(0, 4),
	}),
	"false" => Box::new(Expr::Bln{
		val: false,
		span: Span::new(0, 5),
	}),
};

Iden: String = {
	<l:@L> <val:r"[a-zA-Z_][a-zA-Z0-9_]*"> <r:@L> => val.to_string(),
};

OpInp: Box<Expr> = {
	#[precedence(level="0")]
	Atom => <>,
	#[precedence(level="1")] #[assoc(side="left")]
	UnaryOp,
	#[precedence(level="2")] #[assoc(side="left")]
	Bracketed,
};

UnaryOp: Box<Expr> = {
	#[precedence(level="0")]
	"--" <expr:OpInp> => Box::new(Expr::UnaryOp {
		op: UnaryOp::Dec,
		expr: expr,
	}),
	#[precedence(level="1")]
	"++" <expr:OpInp> => Box::new(Expr::UnaryOp {
		op: UnaryOp::Inc,
		expr: expr,
	}),
	#[precedence(level="2")]
	"&" <expr:OpInp> => Box::new(Expr::UnaryOp {
		op: UnaryOp::Ref,
		expr: expr,
	}),
	#[precedence(level="3")]
	"*" <expr:OpInp> => Box::new(Expr::UnaryOp {
		op: UnaryOp::Deref,
		expr: expr,
	}),
	#[precedence(level="4")]
	"+" <expr:OpInp> => Box::new(Expr::UnaryOp {
		op: UnaryOp::Pos,
		expr: expr,
	}),
	#[precedence(level="5")]
	"-" <expr:OpInp> => Box::new(Expr::UnaryOp {
		op: UnaryOp::Neg,
		expr: expr,
	}),
	#[precedence(level="6")]
	"!" <expr:OpInp> => Box::new(Expr::UnaryOp {
		op: UnaryOp::Not,
		expr: expr,
	}),
	#[precedence(level="7")]
	"~" <expr:OpInp> => Box::new(Expr::UnaryOp {
		op: UnaryOp::BitNot,
		expr: expr,
	}),
};

BinaryOp: Box<Expr> = {
	#[precedence(level="0")]
	<l:OpInp> "*" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Mul,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="1")] #[assoc(side="left")]
	<l:OpInp> "/" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Div,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="2")] #[assoc(side="left")]
	<l:OpInp> "%" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Mod,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="3")] #[assoc(side="left")]
	<l:OpInp> "+" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Add,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="4")] #[assoc(side="left")]
	<l:OpInp> "-" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Sub,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="5")] #[assoc(side="left")]
	<l:OpInp> "<<" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Shl,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="6")] #[assoc(side="left")]
	<l:OpInp> ">>" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Shr,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="7")] #[assoc(side="left")]
	<l:OpInp> "<" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Lt,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="8")] #[assoc(side="left")]
	<l:OpInp> "<=" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Lte,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="9")] #[assoc(side="left")]
	<l:OpInp> ">" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Gt,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="10")] #[assoc(side="left")]
	<l:OpInp> ">=" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Gte,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="11")] #[assoc(side="left")]
	<l:OpInp> "==" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Eq,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="12")] #[assoc(side="left")]
	<l:OpInp> "!=" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Neq,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="13")] #[assoc(side="left")]
	<l:OpInp> "&" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::BitAnd,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="14")] #[assoc(side="left")]
	<l:OpInp> "^" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::BitXor,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="15")] #[assoc(side="left")]
	<l:OpInp> "|" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::BitOr,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="16")] #[assoc(side="left")]
	<l:OpInp> "&&" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::And,
		lhs: l,
		rhs: r,
	}),
	#[precedence(level="17")] #[assoc(side="left")]
	<l:OpInp> "||" <r:Expr> => Box::new(Expr::BinaryOp {
		op: BinaryOp::Or,
		lhs: l,
		rhs: r,
	}),
};

Call: Box<Expr> = {
	<name:Iden> "(" <args:Comma<Expr>> ")" => Box::new(Expr::Call {
		name: name,
		args: args,
		generics: None,
	}),
	<name:Iden> "::<" <gens:Comma<Type>> ">" "(" <args:Comma<Expr>> ")" => Box::new(Expr::Call {
		name: name,
		args: args,
		generics: Some(gens),
	}),
};

Index: Box<Expr> = {
	<name:Iden> <v:("[" <Expr> "]")+> => Box::new(Expr::Index {
		name: name,
		indices: v
	}),
};

MemAccessOperands: Box<Expr> = {
    #[precedence(level="0")]
	Numeric,
	Strng,
	Flt,
	Chr,
	Bln,
	<l:@L> <val:Iden> <r:@R> => Box::new(Expr::Iden{
		val: val,
		span: Span::new(l as u32, r as u32),
	}),
	Index,
	Call,
};

MemberAccess: Box<Expr> = {
	<name:MemAccessOperands> <v:("." <MemAccessOperands>)+> => {
		let mut base = name;
		for m in v {
			base = Box::new(Expr::MemberAccess {
				name: base,
				member: m,
			});
		}
		base
	},
};

Type: Box<Type> = {
	BuilinType => Box::new(Type::Builtin(<>)),
	Pointer => <>,
	UserDefined => <>,
	Array => <>,
};

BuilinType: BuiltinType = {
	"i8" => BuiltinType::I8,
	"i16" => BuiltinType::I16,
	"i32" => BuiltinType::I32,
	"i64" => BuiltinType::I64,
	"u8" => BuiltinType::U8,
	"u16" => BuiltinType::U16,
	"u32" => BuiltinType::U32,
	"u64" => BuiltinType::U64,
	"f32" => BuiltinType::F32,
	"f64" => BuiltinType::F64,
	"void" => BuiltinType::Void,
	"chr" => BuiltinType::Chr,
	"bln" => BuiltinType::Bln,
	"str" => BuiltinType::Str,
};

Pointer: Box<Type> = {
	"ptr" <n:"*"+> <t:Type> => {
		let nr = n.len();
		let mut base = t;
		for _ in 0..nr {
			base = Box::new(Type::Pointer(base));
		}
		base
	}
};

Array: Box<Type> = {
	"[" <t:Type> ";" <s:r"[0-9]+"> "]" => Box::new(Type::Array {
		base: t,
		length: s.parse().unwrap(),
	}),
};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

UserDefined: Box<Type> = {
	<name:Iden> "<" <args:Comma<Type>> ">" => Box::new(Type::UserDefined {
		name: name,
		generic_args: Some(args),
	}),
	<name:Iden> => Box::new(Type::UserDefined {
		name: name,
		generic_args: None,
	}),
};

VarDecl: Box<Stmt> = {
	<name:Iden> ":" <t:Type> "=" <val:Expr> => Box::new(Stmt::VarDecl {
		name: name,
		ty: t,
		value: Some(val),
	}),
	<name:Iden> ":" <t:Type> => Box::new(Stmt::VarDecl {
		name: name,
		ty: t,
		value: None,
	}),
};

Block: Box<Stmt> = {
	"{" <stmts:Stmt*> "}" => Box::new(Stmt::Block(stmts)),
};

While: Box<Stmt> = {
	"while" "(" <cond:Expr> ")" <body:Stmt> => Box::new(Stmt::While {
		cond: cond,
		body: body,
	}),
};

For: Box<Stmt> = {
	"for" "(" <init:Stmt> <cond:Expr> ";" <step:Stmt> ")" <body:Stmt> => Box::new(Stmt::For {
		init: init,
		cond: cond,
		step: step,
		body: body,
	}),
	"for" "(" <init:Stmt> <cond:Expr> ")" <body:Stmt> => Box::new(Stmt::For {
		init: init,
		cond: cond,
		step: Box::new(Stmt::Expr(Box::new(Expr::Numeric{
			val: 1,
			span: Span::new(0, 0),
		}))),
		body: body,
	}),
	"for" "(" <init:Stmt> ";" <step:Stmt> ")" <body:Stmt> => Box::new(Stmt::For {
		init: init,
		cond: Box::new(Expr::Bln{
			val: true,
			span: Span::new(0, 0),
		}),
		step: step,
		body: body,
	}),
	"for" "(" <init:Stmt> ")" <body:Stmt> => Box::new(Stmt::For {
		init: init,
		cond: Box::new(Expr::Bln{
			val: true,
			span: Span::new(0, 0),
		}),
		step: Box::new(Stmt::Expr(Box::new(Expr::Numeric{
			val: 1,
			span: Span::new(0, 0),
		}))),
		body: body,
	}),
};

ValidIfTail: Box<Stmt> = {
	Block,
	<Expr> ";" => Box::new(Stmt::Expr(<>)),
	Return,
	Continue,
	Break,
};

If : Box<Stmt> = {
	"if" "(" <cond:Expr> ")" <body:ValidIfTail> => Box::new(Stmt::If {
		cond: cond,
		body: body,
		els: None,
	}),
	"if" "(" <cond:Expr> ")" <body:ValidIfTail> "else" <else_body:Stmt> => Box::new(Stmt::If {
		cond: cond,
		body: body,
		els: Some(else_body),
	}),
};

Return: Box<Stmt> = {
	"ret" <val:Expr?> ";" => Box::new(Stmt::Return(val)),
};

Continue: Box<Stmt> = {
	"cont" ";" => Box::new(Stmt::Continue),
};

Break: Box<Stmt> = {
	"brk" ";" => Box::new(Stmt::Break),
};

Plud<T>: Vec<T> = {
	<mut v:(<T> "+")*> <e:T?> => match e { // (2)
		None => v,
		Some(e) => {
			v.push(e);
			v
		}
	}
};

GenericType: Box<GenericType> = {
	<name:Iden> => Box::new(GenericType::new(name, None)),
	<name:Iden> ":" <t:Plud<Type>> => Box::new(GenericType::new(name, Some(t))),
};

GenricDecl: Vec<Box<GenericType>> = {
    <Comma<GenericType>> => <>
};

StructDecl: Box<Stmt> = {
	"struct" <name:Iden> "{" <fields:Comma<VarDecl>> "}" => Box::new(Stmt::StructDecl {
		name: name,
		fields: fields,
		generics: None,
	}),
	"struct" <name:Iden> "<" <gens:GenricDecl> ">" "{" <fields:Comma<VarDecl>> "}" => Box::new(Stmt::StructDecl {
		name: name,
		fields: fields,
		generics: Some(gens),
	}),
};

FunctionDecl: Box<Stmt> = {
	"fnc" <name:Iden> "(" <args:Comma<VarDecl>> ")" ":" <ret:Type> <body:Block> => Box::new(Stmt::FunctionDecl {
		name: name,
		args: args,
		ret: ret,
		body: Some(body),
		generics: None,
		isvararg: false,
	}),
	"fnc" <name:Iden> "<" <gens:GenricDecl> ">" "(" <args:Comma<VarDecl>> ")" ":" <ret:Type> <body:Block> => Box::new(Stmt::FunctionDecl {
		name: name,
		args: args,
		ret: ret,
		body: Some(body),
		generics: Some(gens),
		isvararg: false,
	}),
	"fnc" <name:Iden> "<" <gens:GenricDecl> ">" "(" <args:Comma<VarDecl>> "..." ")" ":" <ret:Type> <body:Block> => Box::new(Stmt::FunctionDecl {
		name: name,
		args: args,
		ret: ret,
		body: Some(body),
		generics: Some(gens),
		isvararg: true,
	}),
	"fnc" <name:Iden> "(" <args:Comma<VarDecl>> "..." ")" ":" <ret:Type> <body:Block> => Box::new(Stmt::FunctionDecl {
		name: name,
		args: args,
		ret: ret,
		body: Some(body),
		generics: None,
		isvararg: true,
	}),
	"fnc" <name:Iden> "(" <args:Comma<VarDecl>> ")" ":" <ret:Type> ";" => Box::new(Stmt::FunctionDecl {
		name: name,
		args: args,
		ret: ret,
		body: None,
		generics: None,
		isvararg: false,
	}),
	"fnc" <name:Iden> "<" <gens:GenricDecl> ">" "(" <args:Comma<VarDecl>> ")" ":" <ret:Type> ";" => Box::new(Stmt::FunctionDecl {
		name: name,
		args: args,
		ret: ret,
		body: None,
		generics: Some(gens),
		isvararg: false,
	}),
	"fnc" <name:Iden> "(" <args:Comma<VarDecl>> "..." ")" ":" <ret:Type> ";" => Box::new(Stmt::FunctionDecl {
		name: name,
		args: args,
		ret: ret,
		body: None,
		generics: None,
		isvararg: true,
	}),
	"fnc" <name:Iden> "<" <gens:GenricDecl> ">" "(" <args:Comma<VarDecl>> "..." ")" ":" <ret:Type> ";" => Box::new(Stmt::FunctionDecl {
		name: name,
		args: args,
		ret: ret,
		body: None,
		generics: Some(gens),
		isvararg: true,
	}),
};

TraitDecl: Box<Stmt> = {
	"trait" <name:Iden> "for" <ty:Type> "{" <methods:(FunctionDecl)+> "}" => Box::new(Stmt::TraitDecl {
		name: name,
		for_ty: ty,
		methods: methods,
	}),
};

VarAssign: Box<Stmt> = {
	<name:Iden> "=" <val:Expr> ";"=> Box::new(Stmt::VarAssign {
		name: name,
		value: val,
		op: AssignOp::Assign,
	}),
	<name:Iden> "+=" <val:Expr> ";" => Box::new(Stmt::VarAssign {
		name: name,
		value: val,
		op: AssignOp::AddAssign,
	}),
	<name:Iden> "-=" <val:Expr> ";" => Box::new(Stmt::VarAssign {
		name: name,
		value: val,
		op: AssignOp::SubAssign,
	}),
	<name:Iden> "*=" <val:Expr> ";" => Box::new(Stmt::VarAssign {
		name: name,
		value: val,
		op: AssignOp::MulAssign,
	}),
	<name:Iden> "/=" <val:Expr> ";" => Box::new(Stmt::VarAssign {
		name: name,
		value: val,
		op: AssignOp::DivAssign,
	}),
	<name:Iden> "%=" <val:Expr> ";" => Box::new(Stmt::VarAssign {
		name: name,
		value: val,
		op: AssignOp::ModAssign,
	}),
};

DerefAssign: Box<Stmt> = {
	<val:UnaryOp> "=" <expr:Expr> ";" => Box::new(Stmt::DerefAssign {
		value: val,
		expr: expr,
		op: AssignOp::Assign,
	}),
	<val:UnaryOp> "+=" <expr:Expr> ";" => Box::new(Stmt::DerefAssign {
		value: val,
		expr: expr,
		op: AssignOp::AddAssign,
	}),
	<val:UnaryOp> "-=" <expr:Expr> ";" => Box::new(Stmt::DerefAssign {
		value: val,
		expr: expr,
		op: AssignOp::SubAssign,
	}),
	<val:UnaryOp> "*=" <expr:Expr> ";" => Box::new(Stmt::DerefAssign {
		value: val,
		expr: expr,
		op: AssignOp::MulAssign,
	}),
	<val:UnaryOp> "/=" <expr:Expr> ";" => Box::new(Stmt::DerefAssign {
		value: val,
		expr: expr,
		op: AssignOp::DivAssign,
	}),
	<val:UnaryOp> "%=" <expr:Expr> ";" => Box::new(Stmt::DerefAssign {
		value: val,
		expr: expr,
		op: AssignOp::ModAssign,
	}),
};

NameVal: (String, Box<Stmt>) = {
	<name:Iden> "=" <val:Stmt> => (name, val),
};

StructAssign: Box<Stmt> = {
	<name:Iden> "=" <sname:Iden> "{" <fields:Comma<NameVal>> "}" ";" => Box::new(Stmt::StructAssign {
		name: name,
		sname: sname,
		fields: fields,
	}),
};

StructMemberAssign: Box<Stmt> = {
	<name:MemberAccess> "=" <val:Expr> ";" => Box::new(Stmt::StructMemberAssign {
		name: name,
		value: val,
		op: AssignOp::Assign,
	}),
	<name:MemberAccess> "+=" <val:Expr> ";" => Box::new(Stmt::StructMemberAssign {
		name: name,
		value: val,
		op: AssignOp::AddAssign,
	}),
	<name:MemberAccess> "-=" <val:Expr> ";" => Box::new(Stmt::StructMemberAssign {
		name: name,
		value: val,
		op: AssignOp::SubAssign,
	}),
	<name:MemberAccess> "*=" <val:Expr> ";" => Box::new(Stmt::StructMemberAssign {
		name: name,
		value: val,
		op: AssignOp::MulAssign,
	}),
	<name:MemberAccess> "/=" <val:Expr> ";" => Box::new(Stmt::StructMemberAssign {
		name: name,
		value: val,
		op: AssignOp::DivAssign,
	}),
	<name:MemberAccess> "%=" <val:Expr> ";" => Box::new(Stmt::StructMemberAssign {
		name: name,
		value: val,
		op: AssignOp::ModAssign,
	}),
};

ArrayAssign: Box<Stmt>  = {
	<name:Iden> "=" "[" <vals:Comma<Expr>> "]" ";" => Box::new(Stmt::ArrayAssign {
		name: name,
		value: vals,
	}),
};

ArrayMemberAssign: Box<Stmt> = {
	<name:Index> "=" <value:Expr> ";" => Box::new(Stmt::ArrayMemberAssign {
		element: name,
		value: value,
		op: AssignOp::Assign,
	}),
	<name:Index> "+=" <value:Expr> ";" => Box::new(Stmt::ArrayMemberAssign {
		element: name,
		value: value,
		op: AssignOp::AddAssign,
	}),
	<name:Index> "-=" <value:Expr> ";" => Box::new(Stmt::ArrayMemberAssign {
		element: name,
		value: value,
		op: AssignOp::SubAssign,
	}),
	<name:Index> "*=" <value:Expr> ";" => Box::new(Stmt::ArrayMemberAssign {
		element: name,
		value: value,
		op: AssignOp::MulAssign,
	}),
	<name:Index> "/=" <value:Expr> ";" => Box::new(Stmt::ArrayMemberAssign {
		element: name,
		value: value,
		op: AssignOp::DivAssign,
	}),
	<name:Index> "%=" <value:Expr> ";" => Box::new(Stmt::ArrayMemberAssign {
		element: name,
		value: value,
		op: AssignOp::ModAssign,
	}),
};
